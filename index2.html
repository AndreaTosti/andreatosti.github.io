<html lang="it">

<head>
<meta charset="utf-8"/>
<title>Edit & Play</title>
<style>
    body
    {
        background-color: #ffffff;
    }
    div
    {
        width: 1520px;
        height: 42px;
        border: 1px solid black;
        background: linear-gradient(to bottom, rgba(0,183,234,1) 0%,rgba(0,158,195,1) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#00b7ea', endColorstr='#009ec3',GradientType=0 ); /* IE6-9 */
    }

    .scrollabletextbox
    {
        width: 370px;
        height: 34px;
        border: 1px solid green;
        position: absolute;
        font-family: Verdana, Tahoma, Arial, Helvetica, sans-serif;
        font-size: 12px;
        margin: 4px 2px;
        padding: 7px 10px;
        text-align: center;
        text-decoration: none;
        /*
           display: inline-block;
        */
        display: none;

        overflow: auto;
    }

    .button
    {
        background-color: #008CBA;
        border: 1px solid green;
        color: white;
        padding: 7px 0 6px;
        text-align: center;
        text-decoration: none;
        display: inline-block;
        font-family: Consolas, Charcoal, sans-serif;
        font-size: 16px;
        margin: 4px 2px 3px 7px;
        cursor: pointer;

        /* per rendere il testo non selezionabile */
        -webkit-user-select: none; /* Safari */
        -moz-user-select: none; /* Firefox */
        -ms-user-select: none; /* IE10+/Edge */
        user-select: none; /* Standard */
    }

    .dropdown:hover .menu
    {
        display: block;
    }

    .disabled
    {
        opacity: 0.4;
        cursor: not-allowed;
    }

    .titolo
    {
        padding-left: 10px;
         font-family: Consolas, Charcoal, sans-serif;
         font-size: 21px;
         letter-spacing: 0.4px;
         word-spacing: 1.4px;
         font-weight: 400;
         text-decoration: solid rgb(68, 68, 68);
         font-style: normal;
         font-variant: full-width;
         text-transform: none;

         /* testo non selezionabile */
         -webkit-user-select: none; /* Safari */
         -moz-user-select: none; /* Firefox */
         -ms-user-select: none; /* IE10+/Edge */
         user-select: none; /* Standard */
    }

    .titoloDx
    {
        padding-left: 70px;
    }

    .titoloSx
    {
        padding-left: 10px;
    }

    .titoloGrigio
    {
        color: rgba(3, 6, 4, 0.3);
    }

    .titoloBianco
    {
        color: #ffffff;
    }

    .switch
    {
        padding-top: 22px;
        padding-left: 0;
        position: absolute;
        display: inline-block;
        width: 60px;
        height: 15px;
    }

    .switch input
    {
        opacity: 0;
        width: 0;
        height: 0;
    }

    .slider
    {
        position: absolute;
        cursor: pointer;
        top: 4px;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: #008CBA;
        -webkit-transition: .4s;
        transition: .4s;
    }

    .slider:before
    {
        position: absolute;
        content: "";
        height: 26px;
        width: 26px;
        left: 4px;
        bottom: 4px;
        background-color: white;
        -webkit-transition: .4s;
        transition: .4s;
    }

    input:checked + .slider
    {
        background-color: #008CBA;
    }

    input:focus + .slider
    {
        box-shadow: 0 0 1px #008CBA;
    }

    input:checked + .slider:before
    {
        -webkit-transform: translateX(26px);
        -ms-transform: translateX(26px);
        transform: translateX(26px);
    }

    .slider.round
    {
        border-radius: 34px;
    }

    .slider.round:before
    {
        border-radius: 50%;
    }

    .menu
    {
        background: none;
        padding-top: 6px;
        margin-left: -1px;
        display: none;
        position: absolute;
        z-index: 1;
    }

    .menu a
    {
        display: block;
        width: 132px;
        background: linear-gradient(to bottom, rgba(0,183,234,1) 0%,rgba(0,158,195,1) 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */
        border: 1px solid green;
        text-decoration:none;
        font-family: Consolas, Charcoal, sans-serif;
        font-size: 14px;
    }

    img
    {
        display: inline-block;
        vertical-align: middle;
        max-width:42px;
        max-height:42px;
        width: auto;
        height: auto;
    }

</style>

</head>
<body>

<div id = "mainDiv">
    <label class="titolo titoloSx titoloBianco" id = "labelPlay">Play</label>

    <label class="switch">
        <input id = "editCheckbox" type="checkbox">
        <span class="slider round"></span>
    </label>

    <label class="titolo titoloDx titoloGrigio"  id = "labelEdit">Edit</label>

    <button class="button disabled" id = "saveStateButton" type="button">Savestate</button>

    <button class="button disabled" id = "loadStateButton" type="button">Loadstate</button>
    <input id="file-input" type="file" accept = ".json" name="name" style="display: none;" />

    <button class="button disabled" id = "insertPolygonButton" type="button">Insert New Polygon</button>

    <button class="button disabled" id = "insertBuildingButton" type="button">
        Insert building
        <span class="menu">

            <a href="#" onClick="chooseBuilding('pylon'); return false;">
                <img alt="pylon" src="tower.svg"/>
                <span style="vertical-align:middle">Pylon</span>
            </a>

            <a href="#" onClick="chooseBuilding('powerplant'); return false;">
                <img alt="powerplant" src="powerplant.svg"/>
                <span style="vertical-align:middle">Powerplant</span>
            </a>

            <a href="#" onClick="chooseBuilding('bitcoinbase'); return false;">
                <img alt="bitcoinbase" src="bitcoinbase.svg"/>
                <span style="vertical-align:middle">BTC Base</span>
            </a>

            <a href="#" onClick="chooseBuilding('mainbitcoinbase'); return false;">
                <img alt="mainbitcoinbase" src="mainbitcoinbase.svg"/>
                <span style="vertical-align:middle">Main BTC</span>
            </a>

        </span>
    </button>

    <button class="button disabled" id = "deleteItemButton" type="button">Delete Item</button>

    <label for="labelInfo"></label><textarea class="scrollabletextbox" id = "labelInfo"></textarea>
</div>

<canvas id="myCanvas" style="border:1px solid black;
            background: url(water.png); ">
    Your browser does not support HTML5 Canvas!
</canvas>

<!-- Sprites presi da
     https://www.flaticon.com/authors/eucalyp
     https://www.flaticon.com/authors/alfredo-hernandezY
     https://www.flaticon.com/authors/srip
     https://www.flaticon.com/authors/prettycons -->

<script type="text/javascript">

    const editCheckbox = document.getElementById("editCheckbox");
    const saveStateButton = document.getElementById("saveStateButton");
    const loadStateButton = document.getElementById("loadStateButton");
    const fileInput = document.getElementById('file-input');
    const insertPolygonButton = document.getElementById("insertPolygonButton");
    const insertBuildingButton = document.getElementById("insertBuildingButton");
    const deleteItemButton = document.getElementById("deleteItemButton");
    const labelPlay = document.getElementById("labelPlay");
    const labelEdit = document.getElementById("labelEdit");
    const labelInfo = document.getElementById("labelInfo");

    window.addEventListener('resize', resizeCanvas, false);

    let state = null;
    let imagesToLoad = 5;

    let createImage = function(src)
    {
        let img = new Image();
        img.src = src;
        img.onload = init();
        img.onerror = function ()
        {
            alert(img.src + 'failed to load.');
        };
        return img;
    };

    let images =
    {
        pylon: createImage("tower.svg"),
        powerplant : createImage("powerplant.svg"),
        bitcoinbase : createImage("bitcoinbase.svg"),
        mainbitcoinbase : createImage("mainbitcoinbase.svg"),
        plug : createImage("plug.svg")
    };

    function chooseBuilding(buildingName)
    {
        state.chosenBuilding = buildingName;
    }

    function resizeCanvas()
    {
        let canvas = document.getElementById('myCanvas');
        let scale = window.devicePixelRatio;
        let displayWidth = window.innerWidth - 18;
        let displayHeight = window.innerHeight - 63;
        let div = document.getElementById("mainDiv");
        div.style.width = displayWidth + "px";
        canvas.style.width = displayWidth + "px";
        canvas.style.height = displayHeight + "px";
        canvas.width = displayWidth * scale;
        canvas.height = displayHeight * scale;
        if(state)
        {
            state.width = canvas.width;
            state.height = canvas.height;
            state.devicePixelRatio = scale;
            state.valid = false;
        }
    }

    editCheckbox.onchange = function ()
    {
        if (editCheckbox.checked)
        {
            labelPlay.className = "titolo titoloSx titoloGrigio";
            labelEdit.className = "titolo titoloDx titoloBianco";
            state.startEditing();
        }
        else
        {
            labelPlay.className = "titolo titoloSx titoloBianco";
            labelEdit.className = "titolo titoloDx titoloGrigio";
            state.endEditing();
        }
    };

    saveStateButton.onclick = function ()
    {
        if(saveStateButton.className === "button disabled")
            return;
        state.endEditing();
        state.startEditing();
        state.saveState();
    };

    loadStateButton.onclick = function ()
    {
        if(loadStateButton.className === "button disabled")
            return;
        state.endEditing();
        state.startEditing();
        fileInput.click();
    };

    //Gestione callback loadState
    fileInput.onchange = function ()
    {
        state.loadState();
    };

    insertPolygonButton.onclick = function ()
    {
        if(insertPolygonButton.className === "button disabled")
            return;
        if(!state.editingNewPolygon && !state.insertingNewBuilding && !state.deletingItem)
            state.insertNewPolygon();
    };

    insertBuildingButton.onclick = function ()
    {
        if(insertBuildingButton.className === "button disabled")
            return;
        if(!state.insertingNewPolygon && !state.editingNewPolygon && !state.deletingItem)
            state.insertNewBuilding();
    };

    deleteItemButton.onclick = function ()
    {
        if(deleteItemButton.className === "button disabled")
            return;
        if( !state.insertingNewPolygon &&
            !state.editingNewPolygon &&
            !state.insertingNewBuilding)
            state.deleteItem();
    };

    let saveData = (function ()
    {
        let a = document.createElement("a");
        document.body.appendChild(a);
        a.style = "display: none";
        return function (data, fileName)
        {
            let json = JSON.stringify(data),
                blob = new Blob([json], {type: "application/json"}),
                url = window.URL.createObjectURL(blob);
            a.href = url;
            a.download = fileName;
            a.click();
            window.URL.revokeObjectURL(url);
        };
    }());

    function loadJSON(path, callback)
    {
        let xobj = new XMLHttpRequest();
        xobj.overrideMimeType("application/json");
        xobj.open('GET', path, true);
        xobj.onreadystatechange = function ()
        {
            if (xobj.readyState === 4 && xobj.status === 200)
            {
                callback(xobj.responseText);
            }
        };
        xobj.send(null);
    }

    //Metodo costruttore per Wire
    function Wire(id1, id2)
    {
        this.id1 = id1 || null;
        this.id2 = id2 || null;
        this.distance = null;
    }

    Wire.prototype.draw = function (ctx)
    {
        if(this.id1 && this.id2)
        {
            ctx.beginPath();

            ctx.fillStyle = '#f9f35b';
            ctx.lineJoin='round';

            let building1 = state.buildings.find(building => building.id === this.id1);
            let building2 = state.buildings.find(building => building.id === this.id2);

            let buildingW1 = building1.w;
            let buildingH1 = building1.h;
            let buildingW2 = building2.w;
            let buildingH2 = building2.h;

            let posB1;
            let posB2;

            if(building1.sprite === "pylon")
            {
                posB1 = {x: building1.x + buildingW1/2, y: building1.y + buildingH1/2 - 15};
                ctx.moveTo(posB1.x, posB1.y);
            }
            else if(building1.sprite === "powerplant")
            {
                posB1 = {x: building1.x + buildingW1 - 14.4, y: building1.y + buildingH1 - 36.4};
                ctx.moveTo(posB1.x, posB1.y);
            }

            if(building2.sprite === "pylon")
            {
                posB2 = {x: building2.x + buildingW2/2, y: building2.y + buildingH2/2 - 15};

                //Disegno il cavo
                ctx.lineTo(posB2.x, posB2.y);

                ctx.strokeStyle = '#B0C4DE';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.strokeStyle = '#d7dad4';
                ctx.lineWidth = 1;
                ctx.stroke();

                //Disegno la "pallina" sul cavo
                ctx.save();
                ctx.beginPath();
                let distance = Math.hypot(posB2.x - posB1.x, posB2.y - posB1.y);
                let position = (state.elapsedTime / (distance / 40)) % 1;
                let ballPosition = {x: posB1.x + (posB2.x - posB1.x) * position ,
                                    y: posB1.y + (posB2.y - posB1.y) * position };
                ctx.translate(ballPosition.x, ballPosition.y);
                for (let i = 10; i > 0; i--)
                {
                    ctx.lineWidth = i;
                    let red = 255 - (i * 15);
                    let green = 255 - (i * 15);
                    ctx.strokeStyle = 'rgb(' + red + ', ' + green + ',' + 0 + ')';
                    ctx.strokeRect(0, 0, 1 ,1);
                }
                ctx.restore();
            }
            else if(building2.sprite === "powerplant")
            {
                posB2 = {x: building2.x + buildingW2 - 14.4, y: building2.y + buildingH2 - 36.4};

                //Disegno il cavo
                ctx.lineTo(posB2.x, posB2.y);

                ctx.strokeStyle = '#B0C4DE';
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.strokeStyle = '#d7dad4';
                ctx.lineWidth = 1;
                ctx.stroke();

                //Disegno la "pallina" sul cavo
                ctx.save();
                ctx.beginPath();
                let distance = Math.hypot(posB1.x - posB2.x, posB1.y - posB2.y);
                let position = (state.elapsedTime / (distance / 40)) % 1;
                let ballPosition = {x: posB2.x + (posB1.x - posB2.x) * position ,
                    y: posB2.y + (posB1.y - posB2.y) * position };
                ctx.translate(ballPosition.x, ballPosition.y);
                for (let i = 10; i > 0; i--)
                {
                    ctx.lineWidth = i;
                    let red = 255 - (i * 15);
                    let green = 255 - (i * 15);
                    ctx.strokeStyle = 'rgb(' + red + ', ' + green + ',' + 0 + ')';
                    ctx.strokeRect(0, 0, 1 ,1);
                }
                ctx.restore();
            }
        }
    };

    // Metodo costruttore per Building
    function Building(x, y, w, h, sprite, id, powered)
    {
        this.x = x || 0;
        this.y = y || 0;
        this.w = w || 10;
        this.h = h || 10;
        this.sprite = sprite || null; //Sprite del building
        this.id = sprite + id;
        this.powered = powered || false;
    }

    Building.prototype.draw = function (ctx)
    {
        let buildingW = this.w;
        let buildingH = this.h;

        //Disegno il punto di ancoraggio
        ctx.beginPath();

        if(this.sprite === "pylon")
        {
            //pylon
            ctx.arc(this.x + buildingW/2, this.y + buildingH/2 - 15, 5, 0, 2 * Math.PI);
            ctx.strokeStyle = '#FFFFFF';
            ctx.fillStyle = '#1E90FF';
        }
        else if(this.sprite === "powerplant")
        {
            //powerplant
            ctx.arc(this.x + buildingW - 14.4, this.y + buildingH - 36.4, 5, 0, 2 * Math.PI);
            ctx.strokeStyle = '#FFFFFF';
            ctx.fillStyle = '#1E90FF';
        }
        else if(this.sprite === "mainbitcoinbase")
        {
            //bitcoinbase - mainbitcoinbase
            ctx.arc(this.x + buildingW/2, this.y + buildingH - 19.77, 13, 0, 2 * Math.PI);
            ctx.strokeStyle = state.strokeMainbitcoinbase + ((state.alphaRGB % 0.5) + 0.5) + ')';
            ctx.fillStyle = state.fillMainbitcoinbase + ((state.alphaRGB % 0.5) + 0.5) + ')';
        }
        else if(this.sprite === "bitcoinbase")
        {
            //bitcoinbase - mainbitcoinbase
            ctx.arc(this.x + buildingW/2, this.y + buildingH - 19.77, 13, 0, 2 * Math.PI);
            if(this.powered)
            {
                ctx.strokeStyle = state.strokeBitcoinbase + ((state.alphaRGB % 0.5) + 0.5) + ')';
                ctx.fillStyle = state.fillBitcoinbase + ((state.alphaRGB % 0.5) + 0.5) + ')';
            }
            else
            {
                ctx.strokeStyle = state.strokeBitcoinbase + 0.3 + ')';
                ctx.fillStyle = state.fillBitcoinbase + 0.3 + ')';
            }
        }
        ctx.lineWidth = "1px";
        ctx.fill();
        ctx.stroke();

        //Se sono in modalità Play e sto inserendo un nuovo Wire
        //Allora evidenzia i building che posso collegare tramite Wire
        if(!state.editing && state.insertingNewWire)
        {
            if(this.sprite === "pylon" || this.sprite === "powerplant")
            {
                //Se il building è stato selezionato come estremo di un Wire
                //e l'altro estremo non è ancora stato definito
                if(state.tempWire.id1 === this.id && !state.tempWire.id2)
                {
                    ctx.fillStyle = "#FF00FF" + "88";   //88 - 50% alpha
                }
                else
                {
                    ctx.fillStyle = "#FAFAD2" + "88";   //88 - 50% alpha
                }
                ctx.fillRect(this.x, this.y,
                    this.w, this.h);
            }
        }

        //Disegno lo sprite
        ctx.drawImage(images[this.sprite], this.x , this.y , this.w, this.h);

    };

    Building.prototype.contains = function(mx, my)
    {
        return (this.x <= mx) && (this.x + this.w >= mx) &&
            (this.y <= my) && (this.y + this.h >= my);
    };

    // Metodo costruttore per Polygon
    function Polygon(x, y, w, h, points, fill)
    {
        this.x = x || 0;
        this.y = y || 0;
        this.w = w || 10;
        this.h = h || 10;

        //Array di punti
        this.points = points || null;

        this.fill = fill || '#ffda1e';
    }

    // Dato il contesto, disegna il Polygon
    Polygon.prototype.draw = function(ctx)
    {
        ctx.fillStyle = this.fill;

        if(this.points == null)
        {
            //In questo caso si tratta della Toolbar

            ctx.strokeStyle = '#000000';

            ctx.fillRect(this.x - 0.5, this.y, this.w + 1, this.h);

            //https://www.w3schools.com/tags/canvas_arc.asp

            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.arc(this.x,this.y + (this.h / 2), (this.h / 2), Math.PI / 2, ((3 * Math.PI) / 2) );
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.arc(this.x + this.w, this.y + (this.h / 2), (this.h / 2), ((3 * Math.PI) / 2), Math.PI / 2);
            ctx.fill();
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(this.x, this.y);
            ctx.lineTo(this.x + this.w, this.y);
            ctx.stroke();

            ctx.beginPath();
            ctx.moveTo(this.x, this.y + this.h);
            ctx.lineTo(this.x + this.w, this.y + this.h);
            ctx.stroke();
        }
        else
        {
            //Disegno il poligono

            ctx.beginPath();
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.lineJoin='bevel';

            ctx.moveTo(this.points[0].x + this.x, this.points[0].y + this.y);

            let tempLabel = "";

            for (let i = 0; i < this.points.length; i++)
            {
                ctx.lineTo(this.points[i].x + this.x, this.points[i].y + this.y);

                if(state.selectedPolygon === this || state.editingNewPolygon)
                {
                    labelInfo.innerText = tempLabel;
                    tempLabel += "(" + (this.points[i].x + this.x) + "," + (this.points[i].y + this.y) + ")";
                }
            }

            ctx.fillStyle = this.fill;

            //Non riempio il polygono finché non è completo l'eventuale nuovo poligono
            //ctx.fill();

            //Disegno il contorno anche mentre disegno un nuovo poligono
            ctx.stroke();

            let len = this.points.length;
            if(this.points[0].x === this.points[len - 1].x && this.points[0].y === this.points[len - 1].y)
            {
                ctx.lineTo(this.points[len - 1].x + this.x, this.points[len - 1].y + this.y);
                ctx.fill();
                ctx.stroke();
            }

            if(state.editingNewPolygon)
            {
                //Aggiungi un pallino e il nuovo lato alla struttura dati

                //Se decido di cambiare il raggio = 10, allora devo fare lo stesso in doUp
                ctx.beginPath();
                ctx.arc(state.tempPolygon.points[0].x,state.tempPolygon.points[0].y, 10, 0, 2 * Math.PI);
                ctx.closePath();
                ctx.stroke();
            }
        }
    };

    // determina se (mx, my) sta dentro il poligono
    Polygon.prototype.contains = function(mx, my)
    {
        if(state.editingNewPolygon)
            return;

        if(this.points == null)
        {
            // In questo caso avrò solo la toolbar
            // quindi controllo anche di esser dentro i due archi della toolbar
            let distsqArc1 = (mx - this.x) * (mx - this.x) +
                (my - (this.y + this.h / 2)) * (my - (this.y + this.h / 2));

            let distsqArc2 = (mx - (this.x + this.w)) * (mx - (this.x + this.w)) +
                (my - (this.y + this.h / 2)) * (my - (this.y + this.h / 2));

            return (distsqArc1 <= (this.h / 2) * (this.h / 2)) ||
                   (distsqArc2 <= (this.h / 2) * (this.h / 2)) ||
                   (
                       (this.x <= mx) && (this.x + this.w >= mx) && (this.y <= my) && (this.y + this.h >= my)
                   );
        }
        else
        {
            // Controllo di essere all'interno del poligono
            state.ctx.lineJoin='round';
            state.ctx.beginPath();
            state.ctx.moveTo(this.points[0].x + this.x, this.points[0].y + this.y);
            for (let i = 0; i < this.points.length; i++)
            {
                state.ctx.lineTo(this.points[i].x + this.x, this.points[i].y + this.y);
            }
            state.ctx.closePath();

            if(state.ctx.isPointInPath(mx,my) || state.ctx.isPointInStroke(mx, my))
            {
                return (true);
            }
            return (false);
        }
    };

    function CanvasState(canvas, scale)
    {
        this.canvas = canvas;
        this.width = canvas.width;
        this.height = canvas.height;
        this.ctx = canvas.getContext('2d');
        this.devicePixelRatio = scale;

        // Fix vari riguardanti le coordinate del mouse

        this.stylePaddingLeft = 0;
        this.stylePaddingTop  = 0;
        this.styleBorderLeft  = 0;
        this.styleBorderTop   = 0;
        if (window.getComputedStyle)
        {
            this.stylePaddingLeft = parseInt(
                getComputedStyle(canvas, null).getPropertyValue('padding-left'));
            this.stylePaddingTop  = parseInt(
                getComputedStyle(canvas, null).getPropertyValue('padding-top'));
            this.styleBorderLeft  = parseInt(
                getComputedStyle(canvas, null).getPropertyValue('border-left-width'));
            this.styleBorderTop   = parseInt(
                getComputedStyle(canvas, null).getPropertyValue('border-top-width'));
        }
        // Some pages have fixed-position bars at the top or left of the page.
        // (i.e., the stumbleupon.com bar)
        // They will break mouse coordinates unless we also account for this offset:
        let html = document.body.parentNode;
        this.htmlTop = html.offsetTop;
        this.htmlLeft = html.offsetLeft;

        /* ------------------- STATO ------------------- */

        // invalidate()
        this.valid = false;

        // array di Polygon
        this.polygons = [];

        // array di Building
        this.buildings = [];

        // serve a creare id univoci per i Building
        this.buildingId = 0;

        // ci dice se stiamo trascinando qualcosa
        this.dragging = false;

        // ci dice se stiamo in modalità editing
        this.editing = false;

        // ci dice se stiamo inserendo il primo vertice di un nuovo poligono
        this.insertingNewPolygon = false;

        // ci dice se stiamo inserendo i vertici di un nuovo poligono
        this.editingNewPolygon = false;

        // teniamo traccia dei vertici del nuovo poligono che stiamo inserendo
        this.tempPolygon = null;

        // ci dice se stiamo inserendo un nuovo Building
        this.insertingNewBuilding = false;

        // ci dice il Building scelto dal menu a tendina
        this.chosenBuilding = null;

        // ci dice se stiamo in modalità eliminazione Polygon / Building
        this.deletingItem = false;

        // ci dice il Polygon selezionato
        this.selectedPolygon = null;

        // ci dice i Building selezionati
        this.selectedBuildings = new Set();

        // ci dice dove abbiamo cliccato rispetto alle coordinate x/y di Polygon / Building
        this.dragoffx = 0;
        this.dragoffy = 0;

        //Ultimo render
        this.lastRender = 0;

        //Ultimo tick
        this.lastTick = 0;

        //Tengo traccia dei secondi passati
        this.seconds = 0;

        // --------------------------------------- //
        // ----------- Stato del gioco ----------- //
        // --------------------------------------- //

        //Tempo trascorso in modalità Play
        this.elapsedTime = 0;

        //Soldi in BTC
        this.money = 0;

        //Fattore di aumento BTC
        this.factor = 0;

        //Nuovo Wire che stiamo inserendo
        this.tempWire = null;

        //Wires che collegano Powerplant e Pylon
        this.wires = [];

        // ci dice se stiamo inserendo un nuovo Wire
        this.insertingNewWire = false;

        //GameToolbar (spostabile ma non eliminabile)
        this.gameToolbar = new Polygon(100/2, 0, 300, 100, null, '#008080');
        this.polygons.push(this.gameToolbar);

        //infoText3, corrisponde a ciò che verrà stampato nella terza riga
        //della GameToolbar
        this.infoText3 = "";

        //infoText4, corrisponde a ciò che verrà stampato nella quarta riga
        //della GameToolbar
        this.infoText4 = "";

        //Colore anello che circonda il cerchio nello sprite "mainbitcoinbase"
        this.strokeMainbitcoinbase = 'rgba(' + 255 + ',' + 255 + ',' + 77 + ', ';

        //Colore anello che circonda il cerchio nello sprite "bitcoinbase"
        this.strokeBitcoinbase = 'rgba(' + 255 + ',' + 255 + ',' + 77 + ', ';

        //Colore simbolo Bitcoin interno al cerchio dello sprite "mainbitcoinbase"
        this.fillMainbitcoinbase = 'rgba(' + 249 + ',' + 196 + ',' + 36 + ', ';

        //Colore simbolo Bitcoin interno al cerchio dello sprite "bitcoinbase"
        this.fillBitcoinbase = 'rgba(' + 249 + ',' + 196 + ',' + 36 + ', ';

//TODO:


        //Trasparenza simbolo Bitcoin interno al cerchio dello sprite "[main]bitcoinbase"
        this.alphaRGB = 1;

        // The following myState var is an example of a closure!
        // Right here "this" means the CanvasState,
        // but we are making events on the Canvas itself,
        // and when the events are fired on the canvas,
        // the variable "this" is going to mean the canvas!
        // Because we still want to use this particular CanvasState
        // in the events, we have to save a reference to it.
        let myState = this;

        //Fix double-click che seleziona il testo nella pagina
        canvas.addEventListener('selectstart',
            function(e) { e.preventDefault(); return false; }, false);

        canvas.addEventListener('mousedown', function(e)
        {
            myState.doDown(e);
        }, true);
        canvas.addEventListener('mousemove', function(e)
        {
            myState.doMove(e);
        }, true);
        canvas.addEventListener('mouseup', function(e)
        {
            myState.doUp(e);
        }, true);

        canvas.addEventListener('touchstart', function(e)
        {
            if (e.targetTouches.length >= 0) myState.doDown(e.changedTouches[0]);
            e.preventDefault();
        }, true);
        canvas.addEventListener('touchmove', function(e)
        {
            if (e.targetTouches.length >= 0) myState.doMove(e.changedTouches[0]);
            e.preventDefault();
        }, true);
        canvas.addEventListener('touchend', function(e)
        {
            if (e.targetTouches.length >= 0) myState.doUp(e.changedTouches[0]);
            e.preventDefault();
        }, true);

        this.selectionColor = '#94cc44';
        this.selectionWidth = 2;

        //setInterval(function() { myState.draw(); }, 30);

        // Chiamata iniziale a requestAnimationFrame
        requestAnimationFrame(function() { myState.draw(); });
    }

    CanvasState.prototype.doDown = function(e)
    {
        //Se sono in modalità Play
        if(!this.editing)
        {
            let pos = this.getPos(e);
            let mx = pos.x;
            let my = pos.y;
            let buildings = this.buildings;
            let lenB = buildings.length;

            //Controllo se ho fatto click sul pulsante "Plug"
            let gameToolbar = this.gameToolbar;

            if( (gameToolbar.x + gameToolbar.w - 10 <= mx) &&
                (gameToolbar.x + gameToolbar.w - 10 + 50 >= mx) &&
                (gameToolbar.y + gameToolbar.h/4 <= my) &&
                (gameToolbar.y + gameToolbar.h/4 + 50 >= my))
            {
                if(!this.insertingNewWire)
                {
                    this.insertingNewWire = true;
                    this.tempWire = new Wire(null, null);
                    this.wires.push(this.tempWire);
                }
                else
                {
                    this.insertingNewWire = false;
                    this.tempWire.id1 = null;
                    this.tempWire.id2 = null;
                    this.tempWire.distance = null;
                    this.tempWire = null;
                }
                this.valid = false;

                return;
            }

            //Se sto inserendo il primo o il secondo estremo del Wire
            if(this.insertingNewWire)
            {
                let wires = this.wires;
                let numWires = this.wires.length;

                //Vado a vedere se ho fatto click su un Building
                for(let i = lenB - 1; i >= 0; i--)
                {
                    if(buildings[i].contains(mx, my))
                    {
                        if(buildings[i].sprite === "pylon" || buildings[i].sprite === "powerplant")
                        {
                            //Se sto inserendo il primo
                            if(!this.tempWire.id1)
                            {
                                this.tempWire.id1 = buildings[i].id;
                            }
                            else if(!this.tempWire.id2)
                            {
                                /*
                                   Per il Building destinatario NON vanno bene i seguenti casi:
                                   Se ho selezionato il Building mittente
                                   Se esiste già un Wire tra mittente e destinatario
                                   Se non bastano i BTC
                                   Se sto tentando di collegare una centrale con un'altra centrale
                                   Se sto tentando di collegare un pylon con un altro pylon
                                */
                                for(let j = 0; j < numWires; j++)
                                {
                                    if((buildings[i].id === wires[j].id2 && this.tempWire.id1 === wires[j].id1)
                                    || (buildings[i].id === wires[j].id1 && this.tempWire.id1 === wires[j].id2))
                                    {
                                        let time  = new Date().toString().slice(16,24);
                                        this.infoText3 = time + " impossibile effettuare";
                                        this.infoText4 = "l'acquisto";
                                        this.insertingNewWire = false;
                                        this.tempWire = null;
                                        this.valid = false;
                                        return;
                                    }
                                    if(buildings[i].id === this.tempWire.id1)
                                    {
                                        let time  = new Date().toString().slice(16,24);
                                        this.infoText3 = time + " impossibile effettuare";
                                        this.infoText4 = "l'acquisto";
                                        this.insertingNewWire = false;
                                        this.tempWire = null;
                                        this.valid = false;
                                        return;
                                    }
                                    let buildingTemp1 = state.buildings.find(building => building.id === this.tempWire.id1);
                                    if(buildings[i].sprite === "powerplant" && buildingTemp1.sprite === "powerplant")
                                    {
                                        let time  = new Date().toString().slice(16,24);
                                        this.infoText3 = time + " impossibile effettuare";
                                        this.infoText4 = "l'acquisto (powerp - powerp)";
                                        this.insertingNewWire = false;
                                        this.tempWire = null;
                                        this.valid = false;
                                        return;
                                    }
                                    if(buildings[i].sprite === "pylon" && buildingTemp1.sprite === "pylon")
                                    {
                                        let time  = new Date().toString().slice(16,24);
                                        this.infoText3 = time + " impossibile effettuare";
                                        this.infoText4 = "l'acquisto (pylon - pylon)";
                                        this.insertingNewWire = false;
                                        this.tempWire = null;
                                        this.valid = false;
                                        return;
                                    }
                                }

                                let buildingTemp1 = state.buildings.find(building => building.id === this.tempWire.id1);
                                let costo = this.distanceBetweenTwoBuildings(buildingTemp1, buildings[i]);

                                let time  = new Date().toString().slice(16,24);
                                if(costo > this.money)
                                {
                                    this.infoText3 = time + " impossibile effettuare";
                                    this.infoText4 = "l'acquisto (richiesti " + costo + "₿)";
                                    this.insertingNewWire = false;
                                    this.tempWire = null;
                                    this.valid = false;
                                    return;
                                }
                                else
                                {
                                    this.money -= costo;
                                    this.infoText3 = time + " acquisto effettuato";
                                    this.infoText4 = "con successo (" + costo + "₿)";
                                    this.tempWire.id2 = buildings[i].id;
                                    this.tempWire.distance = costo;
                                    //Aggiorno lo stato della corrente elettrica dei bitcoinbase
                                    this.updatePowered();
                                    //Aggiorno il fattore dei BTC
                                    this.updateFactor();
                                    this.insertingNewWire = false;
                                    this.tempWire = null;
                                    this.valid = false;
                                    return;
                                }
                            }
                        }
                    }
                }

                this.valid = false;

                return;
            }

        }



        //Il singolo tap non deve settare il dragging a true
        if( this.insertingNewPolygon || this.insertingNewBuilding || this.deletingItem)
            return;

        //Posso spostare i poligoni solo in modalità editing
        if(this.editing)
        {
            let pos = this.getPos(e);
            let mx = pos.x;
            let my = pos.y;

            let buildings = this.buildings;
            let lenB = buildings.length;

            let polygons = this.polygons;
            let lenP = polygons.length;

            //Vedo se ho selezionato la toolbar
            //Scorro l'array al contrario per rispettare
            //primo piano, secondo piano, ecc
            for (let i = lenP - 1; i >= 0; i--)
            {
                if(!polygons[i].points)
                {
                    if (polygons[i].contains(mx, my))
                    {
                        let mySel = polygons[i];
                        this.dragoffx = mx - mySel.x;
                        this.dragoffy = my - mySel.y;
                        this.dragging = true;
                        this.selectedPolygon = mySel;
                        this.valid = false;

                        return;
                    }
                }
            }

            //Se non ho selezionato la toolbar, allora forse ho selezionato un Building
            //e se cosi fosse, sposto solo quello.
            for(let i = lenB - 1; i >= 0; i--)
            {
                if(buildings[i].contains(mx, my))
                {
                    let mySel = buildings[i];
                    this.dragoffx = mx - mySel.x;
                    this.dragoffy = my - mySel.y;
                    this.dragging = true;
                    this.selectedBuildings.clear();
                    this.selectedBuildings.add(mySel);
                    this.selectedPolygon = null;
                    this.valid = false;

                    return;
                }
            }

            //Se non ho selezionato un singolo Building, allora forse ho selezionato
            //un Polygon
            for (let i = lenP - 1; i >= 0; i--)
            {
                if (polygons[i].contains(mx, my))
                {
                    let mySel = polygons[i];
                    this.dragoffx = mx - mySel.x;
                    this.dragoffy = my - mySel.y;
                    this.dragging = true;
                    this.selectedPolygon = mySel;

                    //Seleziono ogni building all'interno del poligono
                    for(let j = lenB - 1; j >= 0; j--)
                    {
                        if(polygons[i].contains(buildings[j].x + buildings[j].w / 2,
                                                buildings[j].y +buildings[j].h / 2))
                        {
                            this.selectedBuildings.add(buildings[j]);
                        }
                    }
                    this.valid = false;

                    return;
                }
            }
        }
        //Se sono arrivato fino a questo punto, vuol dire che non ho selezionato
        //ne' un singolo Building, ne' un singolo Polygon

        this.selectedPolygon = null;
        this.selectedBuildings.clear();
        this.valid = false;
    };

    CanvasState.prototype.doMove = function(e)
    {
        //Se sto inserendo un nuovo Polygon, disegno a ogni spostamento del mouse
        //l'ultimo lato del nuovo Polygon
        if (this.editingNewPolygon)
        {
            let mouse = this.getPos(e);
            if(this.tempPolygon.points.length > 1)
            {
                this.tempPolygon.points[this.tempPolygon.points.length - 1].x = mouse.x;
                this.tempPolygon.points[this.tempPolygon.points.length - 1].y = mouse.y;
            }
            this.valid = false;
        }

        //Se sto trascinando
        if (this.dragging)
        {
            let mouse = this.getPos(e);
            let saveX = null;
            let saveY = null;
            let dx = null;
            let dy = null;

            //Se ho selezionato un Polygon, allora sposto tutti i Building
            //all'interno di esso
            if(this.selectedPolygon)
            {
                //Posizione relativa al poligono
                saveX = this.selectedPolygon.x;
                saveY = this.selectedPolygon.y;

                this.selectedPolygon.x = mouse.x - this.dragoffx;
                this.selectedPolygon.y = mouse.y - this.dragoffy;

                dx = this.selectedPolygon.x - saveX;
                dy = this.selectedPolygon.y - saveY;

                let selectedBuildings = this.selectedBuildings;
                let numSelectedBuildings = selectedBuildings.size;

                if(numSelectedBuildings >= 1)
                {
                    for(let selectedBuilding of this.selectedBuildings)
                    {
                        selectedBuilding.x += dx;
                        selectedBuilding.y += dy;
                    }
                }
            }
            else
            {
                //Altrimenti ho selezionato un Building e sposto solo quello
                dx = mouse.x - this.dragoffx;
                dy = mouse.y - this.dragoffy;

                let selectedBuildings = this.selectedBuildings;
                let numSelectedBuildings = selectedBuildings.size;

                if(numSelectedBuildings >= 1)
                {
                    for(let selectedBuilding of this.selectedBuildings)
                    {
                        selectedBuilding.x = dx;
                        selectedBuilding.y = dy;
                    }
                }
            }

            this.valid = false;
        }

        //Se sono in modalità editing e non sto trascinando
        //allora seleziono automaticamente il Polygon presente sotto al mouse

        if(this.editing && !this.dragging)
        {
            //Serve nel caso in cui mi sposti da un poligono all'altro "senza
            //passare attraverso il mare"
            this.selectedBuildings.clear();

            let pos = this.getPos(e);
            let mx = pos.x;
            let my = pos.y;
            let polygons = this.polygons;
            let lenP = polygons.length;
            let buildings = this.buildings;
            let lenB = buildings.length;


            //Prima controllo se sono sulla toolbar
            for (let i = lenP - 1; i >= 0; i--)
            {
                if(!polygons[i].points)
                {
                    if (polygons[i].contains(mx, my))
                    {
                        let mySel = polygons[i];
                        this.dragoffx = mx - mySel.x;
                        this.dragoffy = my - mySel.y;
                        this.selectedPolygon = mySel;
                        this.valid = false;

                        return;
                    }
                }
            }

            //Altrimenti controllo di essere su un Building
            for(let i = lenB - 1; i >= 0; i--)
            {
                if(buildings[i].contains(mx, my))
                {
                    let mySel = buildings[i];
                    this.dragoffx = mx - mySel.x;
                    this.dragoffy = my - mySel.y;
                    this.selectedBuildings.clear();
                    this.selectedBuildings.add(mySel);
                    this.selectedPolygon = null;
                    this.valid = false;

                    return;
                }
            }

            //Altrimenti controllo di essere su un Polygon
            for (let i = lenP - 1; i >= 0; i--)
            {
                if (polygons[i].contains(mx, my))
                {
                    let mySel = polygons[i];
                    this.dragoffx = mx - mySel.x;
                    this.dragoffy = my - mySel.y;
                    this.selectedPolygon = mySel;

                    //Seleziono ogni Building all'interno del poligono
                    for(let j = lenB - 1; j >= 0; j--)
                    {
                        if(polygons[i].contains(buildings[j].x + buildings[j].w / 2,
                                                buildings[j].y + buildings[j].h / 2))
                        {
                            this.selectedBuildings.add(buildings[j]);
                        }
                    }
                    this.valid = false;

                    return;
                }
            }

            //Se sono fuori da ogni Polygon e da ogni Building, allora non seleziono
            //alcun Polygon / Building (al passaggio del mouse).
            this.selectedPolygon = null;
            this.selectedBuildings.clear();
            this.valid = false;
        }
    };

    CanvasState.prototype.doUp = function(e)
    {
        //Se sto inserendo un nuovo poligono, allora ne creo un'istanza
        if(this.insertingNewPolygon)
        {
            let mouse = this.getPos(e);
            this.editingNewPolygon = true;
            this.tempPolygon = new Polygon(0, 0, 0, 0, null, '#006E51', []);
            this.addPolygon(this.tempPolygon);
            this.tempPolygon.x = 0;
            this.tempPolygon.y = 0;
            this.tempPolygon.points = [];
            this.tempPolygon.points[0] = {x:mouse.x, y:mouse.y};
            //Inizio a disegnare il primo vertice
            this.tempPolygon.points[1] = {x:mouse.x, y:mouse.y};
            this.insertingNewPolygon = false;
            this.valid = false;

            return;
        }

        //Se sto eliminando un elemento (Polygon o Building)
        if(this.deletingItem)
        {
            //Controllo se sono dentro un poligono
            if(this.selectedPolygon != null)
            {
                let polygons = this.polygons;
                for(let i = 0; i < polygons.length && this.selectedPolygon; i++)
                {
                    if(polygons[i].points)
                    {
                        if(this.selectedPolygon.points[0].x === polygons[i].points[0].x &&
                            this.selectedPolygon.points[0].y === polygons[i].points[0].y
                            //Non posso eliminare la toolbar, quindi la escludo
                            && this.selectedPolygon.points)
                        {
                            polygons.splice(i, 1);
                            this.selectedPolygon = null;
                        }
                    }
                }
            }
            //Se ero dentro un poligono, elimino anche i Building sopra di esso

            if(this.selectedBuildings.size > 0)
            {
                let selectedBuildings = this.selectedBuildings;
                let buildings = this.buildings;

                selectedBuildings.forEach(function(selBuilding)
                {
                    //Se ho rimosso un Wire selezionato in modalità Play
                    if(state.tempWire)
                    {
                        if(state.tempWire.id1 === selBuilding.id ||
                            state.tempWire.id2 === selBuilding.id)
                        {
                            state.tempWire.id1 = null;
                            state.tempWire.id2 = null;
                            state.insertingNewWire = null;
                        }
                    }
                    //Tolgo prima i Wire collegati ai Building selezionati
                    for(let i = 0; i < state.wires.length; i++)
                    {
                        if(state.wires[i].id1 === selBuilding.id ||
                           state.wires[i].id2 === selBuilding.id)
                        {
                            state.wires.splice(i, 1);
                        }
                    }
                });

                selectedBuildings.forEach(function(selBuilding)
                {
                    for(let i = buildings.length - 1; i >= 0; i--)
                    {
                        if(selBuilding.x === buildings[i].x && selBuilding.y === buildings[i].y)
                        {
                            buildings.splice(i, 1);
                            selectedBuildings.delete(selBuilding);
                        }
                    }
                });
            }

            this.deletingItem = false;
            this.valid = false;

            return;
        }

        //Se sto inserendo un nuovo Building
        if(this.insertingNewBuilding)
        {
            //Voglio inserire il building solo se ho selezionato un poligono
            //Quindi non posso piazzare il building fuori dai Polygon
            if(this.selectedPolygon != null)
            {
                let mouse = this.getPos(e);
                let buildingW = null;
                let buildingH = null;

                if(this.chosenBuilding === "pylon")
                {
                    buildingW = 40;
                    buildingH = 40;
                }
                else if(this.chosenBuilding === "powerplant"  ||
                        this.chosenBuilding === "bitcoinbase" ||
                        this.chosenBuilding === "mainbitcoinbase")
                {
                    buildingW = 50;
                    buildingH = 50;
                }

                if(this.chosenBuilding)
                {
                    this.addBuilding(
                        new Building(mouse.x - buildingW/2, mouse.y - buildingH/2,
                            buildingW, buildingH, this.chosenBuilding, this.buildingId++, false));
                }

            }

            this.insertingNewBuilding = false;
            this.valid = false;

            return;
        }

        //Se sto editando un nuovo Polygon
        if(this.editingNewPolygon)
        {
            let mouse = this.getPos(e);

            let distsq = (mouse.x - this.tempPolygon.points[0].x) * (mouse.x - this.tempPolygon.points[0].x) +
                (mouse.y - this.tempPolygon.points[0].y) * (mouse.y - this.tempPolygon.points[0].y);

            //Se sono all'interno del "pallino" (sopra al primo vertice), allora
            //faccio corrispondere il primo vertice con l'ultimo
            //altrimenti inserisco il lato aggiornando Width e Height con il massimo di X e Y rispettivamente
            if(distsq <= 10 * 10)
            {
                this.tempPolygon.points[this.tempPolygon.points.length - 1] =
                    {x:this.tempPolygon.points[0].x, y:this.tempPolygon.points[0].y};
                this.editingNewPolygon = false;
            }
            else
            {
                let xMax = this.tempPolygon.points.map(function(p) {return p.x});
                let yMax = this.tempPolygon.points.map(function(p) {return p.y});

                let max_coords =
                {
                    x : Math.max.apply(null, xMax),
                    y : Math.max.apply(null, yMax)
                };

                this.tempPolygon.x = 0;
                this.tempPolygon.y = 0;
                this.tempPolygon.w = max_coords.x;
                this.tempPolygon.h = max_coords.y;

                this.tempPolygon.points.push({x: mouse.x, y: mouse.y});
            }
            this.valid = false;
        }

        this.dragging = false;
        this.selectedBuildings.clear();
        this.selectedPolygon = null;
    };

    CanvasState.prototype.addPolygon = function(polygon)
    {
        this.polygons.push(polygon);
        this.valid = false;
    };

    CanvasState.prototype.addBuilding = function(building)
    {
        this.buildings.push(building);
        this.valid = false;
    };

    CanvasState.prototype.removeLastPolygon = function()
    {
        this.polygons.pop();
        this.valid = false;
    };

    CanvasState.prototype.clear = function()
    {
        this.ctx.clearRect(0, 0, this.width, this.height);
    };

    CanvasState.prototype.updatePowered = function()
    {
        //Azzero lo stato di Powered per tutti i Building
        let buildings = this.buildings;
        let numBuildings = this.buildings.length;
        for(let i = 0; i < numBuildings; i++)
        {
            buildings[i].powered = false;
        }

        let polygons = this.polygons;
        let numPolygons = this.polygons.length;

        let bitcoinbaseBuildings = this.buildings.filter(building => building.sprite === "bitcoinbase");
        let numBitcoinbasebuildings = bitcoinbaseBuildings.length;

        let powerplantBuildings = this.buildings.filter(building => building.sprite === "powerplant");
        let numPowerplantbuildings = powerplantBuildings.length;

        let pylonBuildings = this.buildings.filter(building => building.sprite === "pylon");
        let numPylonbuildings = pylonBuildings.length;

        //Per ogni poligono vedo se questo contiene un "bitcoinbase"
        for(let i = numPolygons - 1; i >= 0; i--)
        {
            //Altrimenti controllo di essere su un Building
            //Seleziono ogni building all'interno del poligono
            for(let j = numBitcoinbasebuildings - 1; j >= 0; j--)
            {
                if(polygons[i].contains(bitcoinbaseBuildings[j].x + bitcoinbaseBuildings[j].w / 2,
                                        bitcoinbaseBuildings[j].y + bitcoinbaseBuildings[j].h / 2))
                {
                    //Se c'è un powerplant, allora c'è corrente elettrica
                    for(let k = numPowerplantbuildings - 1; k >= 0; k--)
                    {
                        if(polygons[i].contains(powerplantBuildings[k].x + powerplantBuildings[k].w / 2,
                                                powerplantBuildings[k].y + powerplantBuildings[k].h / 2))
                        {
                            let building = this.buildings.find(building => building.id === bitcoinbaseBuildings[j].id);
                            building.powered = true;
                        }
                        else
                        {
                            //se non c'è un powerplant, vedo se c'è un pylon
                            for(let l = numPylonbuildings - 1; l >= 0; l--)
                            {
                                if(polygons[i].contains(pylonBuildings[l].x + pylonBuildings[l].w / 2,
                                                        pylonBuildings[l].y + pylonBuildings[l].h / 2))
                                {
                                    //Controllo tutti i Wire, se almeno uno di questi ha come
                                    //estremi (ovvero id1 e id2) il pylon scelto e un
                                    //powerplant qualsiasi, allora c'è corrente elettrica
                                    let pylonsWireSide = this.wires.filter(wire =>
                                        wire.id1 === pylonBuildings[l].id || wire.id2 === pylonBuildings[l].id);
                                    for(let m = numPowerplantbuildings - 1; m >= 0; m--)
                                    {
                                        let powerplantWireSide = pylonsWireSide.filter(wire =>
                                            wire.id1 === powerplantBuildings[m].id ||
                                            wire.id2 === powerplantBuildings[m].id);
                                        if(powerplantWireSide.length > 0)
                                        {
                                            let building = this.buildings.find(building => building.id === bitcoinbaseBuildings[j].id);
                                            building.powered = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        //Condizione di vittoria: tutti i building hanno lo
        //stato powered = true
        if((this.buildings.filter(building =>
            !building.powered && building.sprite === "bitcoinbase")).length === 0)
        {
            let time  = new Date().toString().slice(16,24);
            this.infoText3 = time + " Hai vinto!";
            this.infoText4 = "Tempo di gioco: " +
                Math.floor(this.seconds/60) + "m " +
                Math.floor(this.seconds)%60 + "s";
            this.valid = false;
        }
    };

    CanvasState.prototype.updateFactor = function()
    {
        //Stabilisce il guadagno totale in BTC
        let newFactor = 0;

        let bitcoinbaseBuildings = this.buildings.filter(building =>
            building.sprite === "bitcoinbase" && building.powered);
        let mainbitcoinbaseBuildings = this.buildings.filter(building =>
            building.sprite === "mainbitcoinbase");

        newFactor += bitcoinbaseBuildings.length;
        newFactor += mainbitcoinbaseBuildings.length;

        this.factor = newFactor;
    };

    CanvasState.prototype.distanceBetweenTwoBuildings = function(building1, building2)
    {
        let connectionPoint1 = null;   //building1
        let connectionPoint2 = null;   //building2
        let buildingW1 = building1.w;
        let buildingH1 = building1.h;
        let buildingW2 = building2.w;
        let buildingH2 = building2.h;

        if(building1.sprite === "pylon")
        {
            connectionPoint1 = {x: building1.x + buildingW1/2,
                y: building1.y + buildingH1/2 - 15};
        }
        else if(building1.sprite === "powerplant")
        {
            connectionPoint1 = {x: building1.x + buildingW1 - 14.4,
                y: building1.y + buildingH1 - 36.4};
        }

        if(building2.sprite === "pylon")
        {
            connectionPoint2 = {x: building2.x + buildingW2/2,
                y: building2.y + buildingH2/2 - 15};
        }
        else if(building2.sprite === "powerplant")
        {
            connectionPoint2 = {x: building2.x + buildingW2 - 14.4,
                y: building2.y + buildingH2 - 36.4};
        }

        let distance = Math.hypot(connectionPoint2.x - connectionPoint1.x,
            connectionPoint2.y - connectionPoint1.y);

        return (Math.round(distance));
    };

    CanvasState.prototype.draw = function(timestamp)
    {
        let progress = timestamp - this.lastRender;

        //A prescindere dal fatto che sia stata fatta la INVALIDATE o meno,
        //se non sto editando vuol dire che sto giocando
        //quindi aggiorno lo stato del gioco
        if(!this.editing && progress)
        {
            this.elapsedTime += progress / 1000;

            //Specifico cosa voglio fare ogni secondo
            if(this.elapsedTime - this.seconds >= 1)
            {
                this.seconds = this.elapsedTime;
                this.money += this.factor;
            }

            //Specifico cosa fare ogni 16ms
            if(this.lastTick + 16 <= timestamp)
            {
                this.lastTick = timestamp;
                this.alphaRGB = this.elapsedTime /4;
                this.valid = false;
            }
        }

        //Se ho fatto una Invalidate(), allora ridisegna e metti lo stato a Valid.
        if (!this.valid)
        {
            let ctx = this.ctx;
            let polygons = this.polygons;
            let numPolygons = this.polygons.length;
            let buildings = this.buildings;
            let numBuildings = this.buildings.length;
            let wires = this.wires;
            let numWires = this.wires.length;

            this.clear();

            //Disegno tutti i Polygon tranne la toolbar
            for (let i = 0; i < numPolygons; i++)
            {
                let polygon = polygons[i];
                //Voglio disegnare la toolbar per ultimo (per metterla in primo piano),
                //quindi disegno tutti i Polygon tranne essa.
                if(polygon.points)
                {
                    //Se i Polygon sono fuori dalla canvas, non disegnarli
                    if (polygon.x > this.width || polygon.y > this.height ||
                        polygon.x + polygon.w < 0 || polygon.y + polygon.h < 0)
                        continue;
                    polygons[i].draw(ctx);
                }
            }

            //Disegno tutti i Building
            for(let j = 0; j < numBuildings; j++)
            {
                buildings[j].draw(ctx);
            }

            //Disegno il contorno dei Polygon e della Toolbar (che è un Polygon)
            if (this.selectedPolygon != null)
            {
                ctx.strokeStyle = this.selectionColor;
                ctx.lineWidth = this.selectionWidth;
                let mySel = this.selectedPolygon;
                if(mySel.points == null)
                {
                    ctx.beginPath();
                    ctx.lineWidth = 3;
                    ctx.strokeStyle = '#003300';
                    ctx.arc(mySel.x,mySel.y + (mySel.h / 2),
                        (mySel.h / 2), Math.PI / 2, ((3 * Math.PI) / 2) );
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(mySel.x + mySel.w, mySel.y + (mySel.h / 2),
                        (mySel.h / 2), ((3 * Math.PI) / 2), Math.PI / 2);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(mySel.x, mySel.y);
                    ctx.lineTo(mySel.x + mySel.w, mySel.y);
                    ctx.stroke();
                    ctx.beginPath();
                    ctx.moveTo(mySel.x, mySel.y + mySel.h);
                    ctx.lineTo(mySel.x + mySel.w, mySel.y + mySel.h);
                    ctx.stroke();
                }
                else
                {
                    ctx.lineWidth = 3;
                    ctx.lineJoin='round';
                    ctx.beginPath();
                    ctx.moveTo(mySel.points[0].x + mySel.x, mySel.points[0].y + mySel.y);
                    for (let i = 0; i < mySel.points.length; i++)
                    {
                        ctx.lineTo(mySel.points[i].x + mySel.x, mySel.points[i].y + mySel.y);
                    }
                    ctx.closePath();
                    ctx.stroke();
                }
            }

            //Disegno anche il contorno dei buildings selezionati
            for(let selectedBuilding of this.selectedBuildings)
            {
                ctx.strokeRect(selectedBuilding.x, selectedBuilding.y,
                               selectedBuilding.w, selectedBuilding.h);
            }

            //Disegno tutti i Wire solo se sono in modalità Play
            if(!this.editing)
            {
                for(let i = 0; i < numWires; i++)
                {
                    wires[i].draw(ctx);
                }
            }

            //Disegno un testo sopra ogni building che posso collegare tramite
            //il Wire avente come contenuto il prezzo in BTC
            if(this.insertingNewWire)
            {
                if(this.tempWire.id1)
                {
                    let selBuilding = this.buildings.find(building => building.id === this.tempWire.id1);

                    for(let i = 0; i < numBuildings; i++)
                    {
                        //Disegno il testo solo sopra i pylon e i powerplant
                        if(buildings[i].sprite !== "pylon" && buildings[i].sprite !== "powerplant")
                            continue;

                        let distance = this.distanceBetweenTwoBuildings(selBuilding, buildings[i]);

                        ctx.lineJoin = 'round';
                        ctx.lineWidth = 3;
                        ctx.strokeStyle = 'black';
                        ctx.strokeText(distance + '₿', buildings[i].x, buildings[i].y);

                        ctx.fillStyle = "#E0FFFF";
                        ctx.font = "18px Arial";
                        ctx.fillText(distance + '₿', buildings[i].x, buildings[i].y);
                    }
                }
            }

            //Disegno la toolbar per ultimo, cosi da farla andare in primo piano
            for(let i = 0; i < numPolygons; i++)
            {
                let polygon = polygons[i];
                if(!polygon.points)
                {
                    if (polygon.x > this.width || polygon.y > this.height ||
                        polygon.x + polygon.w < 0 || polygon.y + polygon.h < 0)
                        continue;
                    polygons[i].draw(ctx);

                    //Disegno le scritte
                    let riga1 = {text: "BTC: " + Math.floor(this.money),
                                 posx: polygon.x, posy: polygon.y + 20};
                    let riga2 = {text: "Tempo di gioco: " + Math.floor(this.seconds/60) + "m " +
                                 Math.floor(this.seconds)%60 + "s",
                                 posx: polygon.x, posy: polygon.y + 40};
                    let riga3 = {text: this.infoText3,
                                 posx: polygon.x, posy: polygon.y + 65};
                    let riga4 = {text: this.infoText4,
                        posx: polygon.x, posy: polygon.y + 85};

                    ctx.lineJoin = 'round';

                    ctx.fillStyle = "#E0FFFF";
                    ctx.font = "17px Arial";
                    ctx.fillText(riga1.text, riga1.posx, riga1.posy);
                    ctx.fillText(riga2.text, riga2.posx, riga2.posy);
                    ctx.fillText(riga3.text, riga3.posx, riga3.posy);
                    ctx.fillText(riga4.text, riga4.posx, riga4.posy);

                    ctx.drawImage(images["plug"], polygon.x + polygon.w - 10, polygon.y + polygon.h/4, 50, 50);

                    if(this.insertingNewWire)
                    {
                        ctx.lineWidth = 2;
                        ctx.lineJoin='round';
                        ctx.strokeStyle = '#ffff00';
                    }
                    else
                    {
                        ctx.strokeStyle = 'white';
                    }
                    ctx.strokeRect(polygon.x + polygon.w - 10, polygon.y + polygon.h/4, 50, 50);

                }
            }

            this.valid = true;
        }

        this.lastRender = timestamp;
        requestAnimationFrame(function(timestamp) { state.draw(timestamp); });
    };

    //Restituisco la posizione del mouse relativa allo stato della Canvas
    CanvasState.prototype.getPos = function(e)
    {
        let element = this.canvas;
        let offsetX = 0;
        let offsetY = 0;
        let mx;
        let my;

        // Compute the total offset
        if (element.offsetParent !== undefined)
        {
            do
            {
                offsetX += element.offsetLeft;
                offsetY += element.offsetTop;
            }while((element = element.offsetParent));
        }

        // Add padding and border style widths to offset
        // Also add the <html> offsets in case there's a position:fixed bar
        offsetX += this.stylePaddingLeft + this.styleBorderLeft + this.htmlLeft;
        offsetY += this.stylePaddingTop + this.styleBorderTop + this.htmlTop;

        mx = (e.pageX - offsetX) * this.devicePixelRatio;
        my = (e.pageY - offsetY) * this.devicePixelRatio;

        return {x: mx, y: my};
    };

    CanvasState.prototype.startEditing = function()
    {
        this.editing = true;
        saveStateButton.className = "button";
        loadStateButton.className = "button";
        insertPolygonButton.className = "button";
        insertBuildingButton.className = "button dropdown";
        deleteItemButton.className = "button";
        editCheckbox.checked = true;
        //Aggiorno lo stato della corrente elettrica dei bitcoinbase
        this.updatePowered();
        //Aggiorno il fattore dei BTC
        this.updateFactor();
        this.valid = false;
    };

    CanvasState.prototype.endEditing = function()
    {
        //Se stavo editando un nuovo poligono (this.editingNewPolygon),
        //allora devo resettare tempPolygon
        if(this.editingNewPolygon)
        {
            this.tempPolygon = [];
            this.removeLastPolygon();
        }

        this.editing = false;
        this.insertingNewPolygon = false;
        this.insertingNewBuilding = false;
        this.editingNewPolygon = false;
        this.deletingItem = false;
        saveStateButton.className = "button disabled";
        loadStateButton.className = "button disabled";
        insertPolygonButton.className = "button disabled";
        insertBuildingButton.className = "button disabled";
        deleteItemButton.className = "button disabled";
        editCheckbox.checked = false;
        labelInfo.innerText = "";
        //Aggiorno lo stato della corrente elettrica dei bitcoinbase
        this.updatePowered();
        //Aggiorno il fattore dei BTC
        this.updateFactor();
        this.valid = false;
    };

    CanvasState.prototype.saveState = function()
    {
        //il secondo parametro di saveData è il nome del file
        //consigliato durante il salvataggio dello stato
        saveData(state, "save");
        let time  = new Date().toString().slice(16,24);
        state.infoText3 = time + " salvataggio in corso...";
        state.infoText4 = "";
    };

    CanvasState.prototype.loadState = function()
    {
        let file = fileInput.value.split("\\");
        let fileName = file[file.length - 1];

        //Resetto il nome del file altrimenti non ricarica il salvataggio
        //se questo possiede lo stesso nome
        fileInput.value = null;

        let json;
        loadJSON(fileName, function(response)
        {
            json = JSON.parse(response);
            triggered(json);
        });

        function triggered(json)
        {
            //Tolgo tutti i Polygon esistenti e rimuovo il bordo dell'ultimo
            //poligono selezionato
            state.polygons = [];
            state.selectedPolygon = null;

            //Tolgo tutti i Building presenti
            state.buildings = [];
            state.selectedBuildings.clear();

            //Tolto tutti i Wire presenti
            state.wires = [];
            state.tempWire = null;
            state.insertingNewWire = false;

            for(let i = 0; i < json.polygons.length; i++)
            {
                let polygon = json.polygons[i];

                //Se si tratta della toolbar, setta il relativo flag
                if(!polygon.points)
                {
                    state.gameToolbar = new Polygon(polygon.x, polygon.y,
                        polygon.w, polygon.h, polygon.points, polygon.fill);
                    state.polygons.push(state.gameToolbar);
                }
                else
                {
                    state.addPolygon(new Polygon(polygon.x, polygon.y,
                        polygon.w, polygon.h, polygon.points, polygon.fill));
                }
            }
            for(let i = 0; i < json.buildings.length; i++)
            {
                let building = json.buildings[i];
                state.addBuilding(new Building(building.x, building.y,
                    building.w, building.h, building.sprite, state.buildingId++, false));
            }

            let time  = new Date().toString().slice(16,24);
            state.infoText3 = time + " caricamento effettuato";
            state.infoText4 = "con successo!";
            this.valid = false;
        }
    };

    CanvasState.prototype.insertNewPolygon = function()
    {
        this.insertingNewPolygon = true;
    };

    CanvasState.prototype.insertNewBuilding = function()
    {
        this.insertingNewBuilding = true;
    };

    CanvasState.prototype.deleteItem = function()
    {
        this.deletingItem = true;
    };

    CanvasState.prototype.insertNewWire = function()
    {
        this.insertingNewWire = true;
    };

    function init()
    {
        //Solo dopo aver caricato tutte le immagini, inizializza lo stato della Canvas
        if(--imagesToLoad > 0)
            return;

        let mycan = document.getElementById('myCanvas');
        resizeCanvas();
        let scale = window.devicePixelRatio;
        state = new CanvasState(mycan, scale);
    }

</script>

</body>
</html>